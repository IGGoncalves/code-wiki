{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":""},{"location":"leetcode/001_twoSum/","title":"1. Two Sum","text":""},{"location":"leetcode/001_twoSum/#problem-definition","title":"\ud83e\udde9 Problem definition","text":"<p>Given an array of integers <code>nums</code>\u00a0and an integer <code>target</code>, return indices of the two numbers such that they add up to target.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p>"},{"location":"leetcode/001_twoSum/#intuition","title":"\ud83e\udde0 Intuition","text":""},{"location":"leetcode/001_twoSum/#implementation","title":"\ud83d\udee0\ufe0f Implementation","text":"<pre><code>class Solution:\ndef twoSum(self, nums: List[int], target: int) -&gt; List[int]:\nhash_table = dict()\nfor i, num in enumerate(nums):\ncomplement = target - num\nif complement in hash_table:\nreturn [i, hash_table[complement]]\nelse:\nhash_table[num] = i\n</code></pre>"},{"location":"leetcode/001_twoSum/#food-for-thought","title":"\ud83d\udcda Food for thought","text":""},{"location":"leetcode/053_maxSubArray/","title":"53. Maximum Subarray","text":""},{"location":"leetcode/053_maxSubArray/#problem-definition","title":"\ud83e\udde9 Problem definition","text":"<p>Given an integer array <code>nums</code>, find the subarray which has the largest sum and return its sum.</p>"},{"location":"leetcode/053_maxSubArray/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>I had some trouble with this problem since my first guess was to just go for computing every sum for every subarray, meaning that I would test window sizes from 1 to <code>len(nums)</code> and every possible starting position. This worked for the first three tests, but it did not pass the \"time lime exceeded\" test \ud83d\ude14. </p> <p>Based on the \"follow up\" tip, I realized that there was a O(n) solution and also a \"divide and conquer\" approach, so I decided to follow these directions and learn more about them.</p>"},{"location":"leetcode/053_maxSubArray/#implementation","title":"\ud83d\udee0\ufe0f Implementation","text":""},{"location":"leetcode/053_maxSubArray/#time-limit-exceeded-all-the-possibilities","title":"Time limit exceeded: All the possibilities \u231b","text":"<pre><code>class Solution:\ndef maxSubArray(self, nums: List[int]) -&gt; int:\nmax_sum = max(nums)\n# Test different window sizes\nfor i in range(1, len(nums) + 1):\n# Test different starting values\nfor j in range(len(nums) + 1 - i):\ncurrent_sum = sum(nums[j:j+i])\nif current_sum &gt; max_sum:\nmax_sum = current_sum\nreturn max_sum\n</code></pre>"},{"location":"leetcode/053_maxSubArray/#on-solution","title":"O(n) solution","text":"<pre><code>class Solution:\ndef maxSubArray(self, nums: List[int]) -&gt; int:\nmax_value = nums[0]\ncurr_sum = 0\nfor n in nums:\ncurr_sum = max(curr_sum, 0)\ncurr_sum += n\nmax_value = max(max_value, curr_sum)\nreturn max_value\n</code></pre>"},{"location":"leetcode/053_maxSubArray/#food-for-thought","title":"\ud83d\udcda Food for thought","text":""},{"location":"leetcode/088_mergeSortedArray/","title":"88. Merge Sorted Array","text":""},{"location":"leetcode/088_mergeSortedArray/#problem-definition","title":"\ud83e\udde9 Problem definition","text":"<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in non-decreasing order, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p> <p>Merge <code>nums1</code> and <code>nums2</code> into a single array sorted in non-decreasing order.</p> <p>The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first m elements denote the elements that should be merged, and the last <code>n</code> elements are set to 0 and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p>"},{"location":"leetcode/088_mergeSortedArray/#intuition","title":"\ud83e\udde0 Intuition","text":""},{"location":"leetcode/088_mergeSortedArray/#implementation","title":"\ud83d\udee0\ufe0f Implementation","text":"<pre><code>class Solution:\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\ncurrent_idx = m + n - 1\nwhile m &gt; 0 and n &gt; 0:\nif nums1[m -1] &gt; nums2[n - 1]:\nnums1[current_idx] = nums1[m - 1]\nm -= 1\nelse:\nnums1[current_idx] = nums2[n - 1]\nn -= 1\ncurrent_idx -= 1\nwhile n &gt; 0:\nnums1[current_idx] = nums2[n - 1]\nn -= 1\ncurrent_idx -= 1\n</code></pre>"},{"location":"leetcode/088_mergeSortedArray/#food-for-thought","title":"\ud83d\udcda Food for thought","text":"<ul> <li>Two pointers</li> </ul>"},{"location":"leetcode/121_buySellStocks/","title":"121. Best Time to Buy and Sell Stock","text":""},{"location":"leetcode/121_buySellStocks/#problem-definition","title":"\ud83e\udde9 Problem definition","text":"<p>You are given an array prices where <code>prices[i]</code> is the price of a given stock on the $i^{th}$ day.</p> <p>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p> <p>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return <code>0</code>.</p>"},{"location":"leetcode/121_buySellStocks/#intuition","title":"\ud83e\udde0 Intuition","text":""},{"location":"leetcode/121_buySellStocks/#implementation","title":"\ud83d\udee0\ufe0f Implementation","text":""},{"location":"leetcode/121_buySellStocks/#time-limit-exceeded-all-the-possibilities","title":"Time limit exceeded: All the possibilities \u231b","text":"<pre><code>class Solution:\ndef maxProfit(self, prices: List[int]) -&gt; int:\nif len(prices) &lt;= 1:\nreturn 0\nprofit = max([max(prices[i+1:]) - price \nfor i, price in enumerate(prices) \nif i &lt; len(prices) - 1])\nreturn max(profit, 0)\n</code></pre>"},{"location":"leetcode/121_buySellStocks/#food-for-thought","title":"\ud83d\udcda Food for thought","text":""},{"location":"leetcode/217_containsDuplicate/","title":"217. Contains Duplicate","text":""},{"location":"leetcode/217_containsDuplicate/#problem-definition","title":"\ud83e\udde9 Problem definition","text":"<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears at least twice in the array, and return <code>false</code> if every element is distinct.</p>"},{"location":"leetcode/217_containsDuplicate/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The first idea that came to mind was to go through the list and store the values in a new <code>set</code>. While looping, I would check if the current number was in this new set. If it had been previously stored, it meant that the current occurrence was a duplicate.</p> <p>With some further thought, I realized there were other ways of solving this problem. For example, a Pythonic approach would be to simply build a set from the original list (i.e., <code>set(nums)</code>) and compare their lengths. A <code>set</code> does not have duplicates, which means that any duplicates that might exist in the original list would be removed and, consequently, the length of the set would be smaller than that of the list. </p>"},{"location":"leetcode/217_containsDuplicate/#implementation","title":"\ud83d\udee0\ufe0f Implementation","text":""},{"location":"leetcode/217_containsDuplicate/#option-1-building-a-set","title":"Option 1: Building a set","text":"<pre><code>class Solution:\ndef containsDuplicate(self, nums: List[int]) -&gt; bool:\nvisited_numbers = set()\nfor number in nums:\n# If the number was visited before, a duplicate was found\nif number in visited_numbers:\nreturn True\n# Add number to visited numbers\nvisited_numbers.add(number)\nreturn False\n</code></pre>"},{"location":"leetcode/217_containsDuplicate/#option-2-a-more-pythonic-approach","title":"Option 2: A more pythonic approach \ud83d\udc0d","text":"<pre><code>class Solution:\ndef containsDuplicate(self, nums: List[int]) -&gt; bool:\nreturn len(nums) != len(set(nums))\n</code></pre>"},{"location":"leetcode/217_containsDuplicate/#food-for-thought","title":"\ud83d\udcda Food for thought","text":"<ul> <li>Time and space complexity;</li> <li>Python's implementation of <code>sets</code>;</li> </ul>"},{"location":"leetcode/350_intersectTwoArrays/","title":"350. Intersection of Two Arrays II","text":""},{"location":"leetcode/350_intersectTwoArrays/#problem-definition","title":"\ud83e\udde9 Problem definition","text":"<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</p>"},{"location":"leetcode/350_intersectTwoArrays/#intuition","title":"\ud83e\udde0 Intuition","text":""},{"location":"leetcode/350_intersectTwoArrays/#implementation","title":"\ud83d\udee0\ufe0f Implementation","text":"<pre><code>class Solution:\ndef intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:\nintersection = []\nfor num in nums1:\nif num in nums2:\nintersection.append(num)\nnums2.remove(num)\nreturn intersection\n</code></pre>"},{"location":"leetcode/350_intersectTwoArrays/#food-for-thought","title":"\ud83d\udcda Food for thought","text":""}]}